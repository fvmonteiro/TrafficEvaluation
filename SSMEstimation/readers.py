import os
from typing import Union
from typing import List
import warnings

# import numpy as np
import pandas as pd
# from sodapy import Socrata

from vissim_interface import VissimInterface


# from Vehicle import Vehicle


class DataReader:
    relevant_columns = {'time', 'veh_id', 'veh_type', 'link', 'lane',
                        'x', 'vx', 'y', 'leader_id', 'delta_x', 'leader_type',
                        'front_x', 'front_y', 'rear_x', 'rear_y', 'length',
                        'delta_v'}

    def __init__(self, data_dir=None, network_name=None):
        self.data_dir = data_dir
        self.network_name = network_name
        # self.file_name = self.base_file_name
        # Necessary to include in parent if they will always be irrelevant?
        # self.data_source = None

    def load_data(self) -> pd.DataFrame:
        pass

    def select_relevant_columns(self, data):
        columns_to_drop = []
        for col in data.columns:
            if col not in self.relevant_columns:
                columns_to_drop.append(col)
        data.drop(columns=columns_to_drop, inplace=True)


class VissimDataReader(DataReader):
    """Base class to read data generated by VISSIM"""

    vissim_networks_folder = VissimInterface.networks_folder
    # These variables are needed because we only save the simulation number,
    # which doesn't mean much unless all autonomous percentages had the
    # exact same number of simulations.
    # TODO: save this in some permanent file
    # _vehicle_inputs_only_mandatory = [i for i in range(200, 2500, 300)]
    # _autonomous_percentage_vehicle_inputs_map = {
    #     0: _vehicle_inputs, 10: _vehicle_inputs, 20: _vehicle_inputs,
    #     40: _vehicle_inputs, 60: _vehicle_inputs,
    #     80: _vehicle_inputs, 100: _vehicle_inputs
    # }
    _vehicle_inputs = [i for i in range(500, 2501, 500)]
    _autonomous_percentage_vehicle_inputs_map = {
        0: _vehicle_inputs, 25: _vehicle_inputs[-2:], 50: _vehicle_inputs[-2:],
        75: _vehicle_inputs[-2:], 100: _vehicle_inputs,
        '100_percent_autonomous_only_longitudinal_control': _vehicle_inputs[
                                                            -2:-1]
    }
    _first_simulation_number = 2
    _runs_per_input = 10
    _initial_random_seed = 7
    _random_seed_increment = 1

    def __init__(self, network_name, file_format, data_identifier,
                 header_identifier, header_map):

        network_file = VissimInterface.get_file_name_from_network_name(
            network_name)
        network_data_dir = os.path.join(self.vissim_networks_folder,
                                        network_file)
        DataReader.__init__(self, network_data_dir,
                            network_file)
        self.file_format = file_format
        self.data_identifier = data_identifier
        self.header_identifier = header_identifier
        self.header_map = header_map
        # self.data_source = 'VISSIM'

    @staticmethod
    def load_max_deceleration_data():
        """ Loads data describing maximum deceleration distribution per vehicle
         type and velocity

        :return: pandas dataframe with double index
        """
        max_deceleration_data = pd.read_csv(os.path.join(
            VissimDataReader.vissim_networks_folder, 'max_decel_data.csv'))
        kph_to_mps = 1 / 3.6
        max_deceleration_data['vel'] = max_deceleration_data['vel'] * kph_to_mps
        max_deceleration_data.set_index(['veh_type', 'vel'], inplace=True)
        return max_deceleration_data

    def load_data(self, file_identifier: Union[int, str] = 1,
                  autonomous_percentage: [int, str] = 0):
        """ Loads data from simulations of a chosen network

        :param file_identifier: This can be either a integer indicating
         the simulation number or the file name directly
        :param autonomous_percentage: Percentage of autonomous vehicles
         in the simulation. We expect an int, but, for debugging purposes,
         a string with the folder name is also accepted.
        :return: pandas dataframe with the data
        """
        if isinstance(file_identifier, str):
            file_name = file_identifier
        else:
            # Create a three-character string with trailing zeros and then
            # sim_nums (e.g.: _004, _015, _326)
            num_str = '_' + str(file_identifier).rjust(3, '0')
            file_name = (self.network_name + self.data_identifier
                         + num_str + self.file_format)

        if isinstance(autonomous_percentage, str):
            autonomous_percent_str = autonomous_percentage
        else:
            autonomous_percent_str = (str(autonomous_percentage)
                                      + '_percent_autonomous')

        full_address = os.path.join(self.data_dir,
                                    autonomous_percent_str, file_name)
        try:
            with open(full_address, 'r') as file:
                # Skip header lines
                for line in file:
                    # In all VISSIM files, the data starts after a line such as
                    # '$VEHICLE:'. The variable names are listed after the ':'.
                    if line.startswith(self.header_identifier):
                        file_header = (line.partition(':')[-1].rstrip(
                            '\n').split(';'))
                        break
                column_names = []
                for variable_name in file_header:
                    if '(' in variable_name:
                        parenthesis_idx = variable_name.find('(')
                        vehicle_type = variable_name[
                                       parenthesis_idx:variable_name.find(
                                           ')') + 1]
                        variable_name = variable_name[:parenthesis_idx]
                        column_names.append(self.header_map[variable_name]
                                            + vehicle_type)
                    else:
                        column_names.append(self.header_map[variable_name])
                sim_output = pd.read_csv(file, sep=';',
                                         names=column_names,
                                         index_col=False)
        except OSError:
            raise ValueError('No VISSIM file with name {}'.format(file_name))

        sim_output.dropna(axis='columns', how='all', inplace=True)
        sim_output['autonomous_percentage'] = autonomous_percentage
        self._match_sim_number_to_vehicle_input(sim_output)
        return sim_output

    def load_data_with_autonomous_percentage(
            self, autonomous_percentage:
            Union[int, List[int], str, List[str]]) -> pd.DataFrame:
        """Loads data from all simulations with the given autonomous percentages

        :param autonomous_percentage: Percentage of autonomous vehicles
         in the simulation. If this is a list, all the data is appended to a 
         single data frame. We expect an int, but, for debugging purposes, a 
         string with the folder name is also accepted.
        :return: pandas dataframe with the data
        """
        if not isinstance(autonomous_percentage, list):
            autonomous_percentage = [autonomous_percentage]

        data = self.load_data(self.find_highest_file_number(
            autonomous_percentage[0]), autonomous_percentage[0])
        # data['autonomous_percentage'] = autonomous_percentage[0]
        # self._match_sim_number_to_vehicle_input(data)
        for i in range(1, len(autonomous_percentage)):
            new_data = self.load_data(self.find_highest_file_number(
                autonomous_percentage[i]), autonomous_percentage[i])
            # new_data['autonomous_percentage'] = autonomous_percentage[i]
            # self._match_sim_number_to_vehicle_input(new_data)
            data = data.append(new_data)

        return data

    def load_data_from_several_files(self, first_file_number,
                                     last_file_number) -> pd.DataFrame:
        """Reads and aggregates data from several files

        :param first_file_number: simulation run number of the first file
        :param last_file_number: simulation run number of the last file
        :return: single aggregated pandas dataframe """
        sim_output = pd.DataFrame()
        for i in range(first_file_number, last_file_number + 1):
            try:
                if sim_output.empty:
                    sim_output = self.load_data(autonomous_percentage=i)
                else:
                    sim_output = sim_output.append(
                        self.load_data(autonomous_percentage=i))
            except ValueError:
                warnings.warn('Tried to simulations from {} to {}, but stopped '
                              'at {}'.format(first_file_number,
                                             last_file_number, i))
                break
            print(i - first_file_number + 1, ' files read')
        return sim_output

    def find_highest_file_number(self, autonomous_percentage: [int, str]) -> \
            int:
        """"Looks for the file with the highest simulation number. This is
        usually the file containing results from all simulations.

        :param autonomous_percentage: Percentage of autonomous vehicles
         in the simulation. We expect an int, but, for debugging purposes,
         a string with the folder name is also accepted.
        :return: highest simulation number. """
        max_simulation_number = 0
        if isinstance(autonomous_percentage, str):
            autonomous_percentage_folder = os.path.join(
                self.data_dir, autonomous_percentage)
        else:
            autonomous_percentage_folder = os.path.join(
                self.data_dir, str(autonomous_percentage)
                + '_percent_autonomous')
        for file in os.listdir(autonomous_percentage_folder):
            # print(file)
            if (file.startswith(self.network_name + self.data_identifier)
                    and file.endswith(self.file_format)):
                file_no_extension = file.split('.')[0]
                sim_number = int(file_no_extension.split('_')[-1])
                if sim_number > max_simulation_number:
                    max_simulation_number = sim_number
        return max_simulation_number

    def _match_sim_number_to_vehicle_input(self, data):
        """Based on the number of simulations with each autonomous
        percentage, and knowing the set of tested vehicle inputs, we can
        figure out which vehicle input was used in each simulation"""

        if len(data['autonomous_percentage'].unique()) > 1:
            print('When matching simulation number to vehicle input, the data '
                  'should be from simulations with equal autonomous '
                  'percentages.')
            raise ValueError

        autonomous_percentage = data['autonomous_percentage'].iloc[0]
        input_number = (
                (data['simulation_number'] - self._first_simulation_number)
                // self._runs_per_input)
        inputs = [self._autonomous_percentage_vehicle_inputs_map[
                      autonomous_percentage][i] for i in input_number]
        data['input_per_lane'] = inputs
        data['simulation_number'] = self._initial_random_seed + (
            (data['simulation_number'] - self._first_simulation_number)
            % self._runs_per_input) * self._random_seed_increment
        data.rename(columns={'simulation_number': 'random_seed'}, inplace=True)

    def _load_data_from_all_files(self) -> pd.DataFrame:
        """Reads and aggregates data from the all the files in the networks
        folder that match the type of data we're searching for. This is
        mostly useful for vehicle record data, since each file only contains
        data relative to a single simulation"""

        # TODO: still not sure this function is needed here. Given the size
        #  of vehicle records data, it's probably better to read them one by
        #  one and save a smaller aggregated file containing the SSM results.
        sim_output = pd.DataFrame()
        counter = 0
        for file in os.listdir(self.data_dir):
            if file.startswith(self.network_name + self.data_identifier):
                if sim_output.empty:
                    sim_output = self.load_data(autonomous_percentage=file)
                else:
                    sim_output = sim_output.append(
                        self.load_data(autonomous_percentage=file))
                counter += 1
        print(counter, ' files read')
        return sim_output


class VehicleRecordReader(VissimDataReader):
    """Reads vehicle records generated by VISSIM"""

    _file_format = '.fzp'
    _data_identifier = ''
    _header_identifier = '$VEHICLE'
    _header_map = {
        'SIMRUN': 'simulation_number', 'SIMSEC': 'time', 'NO': 'veh_id',
        'VEHTYPE': 'veh_type', 'LANE\\LINK\\NO': 'link',
        'LANE\\INDEX': 'lane', 'POS': 'x', 'SPEED': 'vx',
        'POSLAT': 'y', 'LEADTARGNO': 'leader_id',
        'FOLLOWDIST': 'vissim_delta_x',
        'COORDFRONTX': 'front_x', 'COORDFRONTY': 'front_y',
        'COORDREARX': 'rear_x', 'COORDREARY': 'rear_y',
        'SPEEDDIFF': 'vissim_delta_v', 'LENGTH': 'length'
    }

    # Note: we don't necessarily want all the variables listed in each of the
    # map above

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name, self._file_format,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    def load_data(self, file_identifier=1, autonomous_percentage:
    [int, str] = 0) -> pd.DataFrame:
        """ Loads data from simulations of a chosen network and selects
        the relevant variables to keep.

        :param file_identifier: Number identifying the simulation run
        :param autonomous_percentage: Percentage of autonomous vehicles
         in the simulation. We expect an int, but, for debugging purposes,
         a string with the folder name is also accepted.
        :return: pandas dataframes
        """
        data = VissimDataReader.load_data(self, file_identifier,
                                          autonomous_percentage)
        self.select_relevant_columns(data)
        return data

    def load_data_with_autonomous_percentage(self, autonomous_percentage):
        print('Not yet sure if it is a good idea to have such a function for '
              'vehicle record data.')
        return


class ReducedSpeedAreaReader(VissimDataReader):
    """Reads data from reduced speed areas used in a VISSIM simulation"""

    _file_format = '.att'
    _data_identifier = '_Reduced Speed Areas'
    _header_identifier = '$REDUCEDSPEEDAREA'
    _header_map = {
        'NO': 'number', 'NAME': 'name', 'LANE': 'lane', 'POS': 'position',
        'LENGTH': 'length', 'TIMEFROM': 'time_from', 'TIMETO': 'time_to',
        'DESSPEEDDISTR': 'speed_limit', 'DECEL': 'max_approach_deceleration'
    }

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name, self._file_format,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    def load_data_with_autonomous_percentage(self, autonomous_percentage):
        print('Not yet coded.')
        return


class DataCollectionReader(VissimDataReader):
    """Reads data generated from data collection measurements in VISSIM"""

    _file_format = '.att'
    _data_identifier = '_Data Collection Results'
    _header_identifier = '$DATACOLLECTIONMEASUREMENTEVALUATION'
    _header_map = {
        'SIMRUN': 'simulation_number', 'TIMEINT': 'time_interval',
        'DATACOLLECTIONMEASUREMENT': 'sensor_number',
        'DIST': 'distance', 'VEHS': 'vehicle_count',
        'QUEUEDELAY': 'queue_delay', 'OCCUPRATE': 'occupancy_rate'
    }

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name, self._file_format,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    # def load_data_with_autonomous_percentage(self, autonomous_percentage):
    #     return self.load_data(
    #         self.find_highest_file_number(autonomous_percentage),
    #         autonomous_percentage)


class LinkEvaluationReader(VissimDataReader):
    """Reads data generated from link evaluation measurements in VISSIM"""

    _file_format = '.att'
    _data_identifier = '_Link Segment Results'
    _header_identifier = '$LINKEVALSEGMENTEVALUATION'
    _header_map = {
        'SIMRUN': 'simulation_number', 'TIMEINT': 'time_interval',
        'LINKEVALSEGMENT': 'link_segment_number', 'DENSITY': 'density',
        'DELAYREL': 'delay_relative', 'SPEED': 'average_speed',
        'VOLUME': 'volume'
    }

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name, self._file_format,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    # def load_data_with_autonomous_percentage(self, autonomous_percentage):
    #     return self.load_data(
    #         self.find_highest_file_number(autonomous_percentage),
    #         autonomous_percentage)


class SSMDataReader(VissimDataReader):
    """Reads aggregated SSM data obtained after processing vehicle record
    data"""

    _file_format = '.csv'
    _data_identifier = '_SSM Results'

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name, self._file_format,
                                  self._data_identifier, None, None)

    def load_data(self, file_identifier: int = None,
                  autonomous_percentage: [int, str] = 0):
        """

        :param file_identifier:
        :param autonomous_percentage: Percentage of autonomous vehicles
         in the simulation. We expect an int, but, for debugging purposes,
         a string with the folder name is also accepted.
        :return:
        """
        # We don't have one SSM per simulation as we do with Data Collections
        # and Link Evaluations. So we can set the default to the file with
        # highest number
        if file_identifier is None:
            file_identifier = self.find_highest_file_number(
                autonomous_percentage)

        num_str = '_' + str(file_identifier).rjust(3, '0')
        file_name = (self.network_name + self.data_identifier
                     + num_str + self.file_format)
        if isinstance(autonomous_percentage, str):
            autonomous_percent_str = autonomous_percentage
        else:
            autonomous_percent_str = (str(autonomous_percentage)
                                      + '_percent_autonomous')
        full_address = os.path.join(self.data_dir,
                                    autonomous_percent_str, file_name)
        try:
            sim_output = pd.read_csv(full_address, index_col=False)
        except OSError:
            raise ValueError('No VISSIM file with name {}'.format(file_name))

        sim_output['autonomous_percentage'] = autonomous_percentage
        self._match_sim_number_to_vehicle_input(sim_output)
        return sim_output

    # def load_data_with_autonomous_percentage(self, autonomous_percentage):
    #     return self.load_data(
    #         self.find_highest_file_number(autonomous_percentage),
    #         autonomous_percentage)


class NGSIMDataReader(DataReader):
    """Reads raw vehicle trajectory data from NGSIM scenarios on the US-101"""

    file_extension = '.csv'
    ngsim_dir = ('C:\\Users\\fvall\\Documents\\Research\\TrafficSimulation'
                 '\\NGSIM_original\\')
    location_switch = {'us-101': 'US-101-LosAngeles-CA\\us-101-vehicle'
                                 '-trajectory-data'}
    interval_switch = {1: '0750am-0805am', 2: '0805am-0820am',
                       3: '0820am-0835am'}
    ngsim_to_reader_naming = {'Global_Time': 'time', 'Vehicle_ID': 'veh_id',
                              'v_Class': 'veh_type', 'Local_Y': 'x',
                              'v_Vel': 'vx', 'Local_X': 'y',
                              'Preceding': 'leader_id', 'Lane_ID': 'lane',
                              'Space_Hdwy': 'delta_x', 'v_Length': 'length'}

    def __init__(self, location):
        # self.interval = 0
        try:
            data_dir = os.path.join(self.ngsim_dir,
                                    self.location_switch[location])
            file_name = 'trajectories-'
        except KeyError:
            print('{}: KeyError: location {} not defined'.
                  format(self.__class__.__name__, location))
            data_dir = None
            file_name = None
        DataReader.__init__(self, data_dir, file_name)
        self.data_source = 'NGSIM'

    def load_data(self, interval=1):

        if interval not in self.interval_switch:
            print('Requested interval not available')
            return pd.DataFrame()

        # self.interval = interval
        self.file_name = self.network_name + self.interval_switch[interval]
        full_address = os.path.join(self.data_dir,
                                    self.file_name + self.file_extension)
        try:
            with open(full_address, 'r') as file:
                data = pd.read_csv(file)
                data.rename(columns=self.ngsim_to_reader_naming, inplace=True)
        except OSError:
            raise ValueError('No NGSIM file with name {}'.
                             format(self.file_name))

        self.select_relevant_columns(data)
        return data

    # def get_simulation_identifier(self):
    #     """Returns the time of the day of the data which was loaded last"""
    #     return self.interval_switch[self.interval]


class PostProcessedDataReader(DataReader):
    file_extension = '.csv'
    post_processed_dir = ('C:\\Users\\fvall\\Documents\\Research'
                          '\\TrafficSimulation\\post_processed_data')

    # file_source_dict = {'highway_in_and_out_lanes': 'VISSIM',
    #                     'I710-MultiSec-3mi': 'VISSIM',
    #                     # 'US_101': 'VISSIM',
    #                     'us-101': 'NGSIM',
    #                     'synthetic_data': 'synthetic_data'}

    def __init__(self, data_source, file_name: str = None):
        # if file_name not in self.file_source_dict:
        #     raise ValueError('No post-processed file with name {}'.
        #                      format(file_name))
        self.data_source = data_source
        if (data_source.lower() == 'vissim'
                and file_name in VissimInterface.existing_networks):
            file_name = VissimInterface.existing_networks[file_name]
        elif data_source.lower() == 'ngsim':
            file_name = 'trajectories-'
        elif data_source.lower == 'synthetic':
            file_name = 'synthetic_data'

        data_dir = os.path.join(self.post_processed_dir, self.data_source)
        DataReader.__init__(self, data_dir, file_name)

    def load_data(self, simulation_identifier=1):
        """ Loads post processed vehicle data from VISSIM or NGSIM
        :return: pandas dataframe
        """
        if self.data_source.lower() == 'vissim':
            simulation_identifier = str(simulation_identifier).rjust(3, '0')
            self.network_name += '_' + simulation_identifier
        elif self.data_source.lower() == 'ngsim':
            simulation_identifier = (
                NGSIMDataReader.interval_switch[simulation_identifier])
            self.network_name += simulation_identifier
        elif self.data_source.lower() == 'synthetic_data':
            pass  # self.file_name is already the correct file name
        else:
            raise ValueError('Unknown data source: ', self.data_source)

        full_address = os.path.join(self.data_dir,
                                    self.network_name + self.file_extension)
        return pd.read_csv(full_address)


class OnLineDataReader(DataReader):
    """"Class to read NGSIM data online, commands from
    https://dev.socrata.com/foundry/data.transportation.gov/8ect-6jqj
    Data details in:
    https://data.transportation.gov/Automobiles/Next-Generation-Simulation-
    NGSIM-Vehicle-Trajector/8ect-6jqj"""

    def __init__(self):
        url = "data.transportation.gov"
        database_identifier = "8ect-6jqj"
        DataReader.__init__(self, url, database_identifier)
        self.data_source = 'NGSIM_online'

    # def load_data(self, location='us-101', limit='2000'):
    #     """
    #     :param location: peachtree, i-80, us-101, lankershim
    #     :param limit: max number of rows
    #     :return: pandas dataframe
    #     """
    #     # The get function can receive SQL-like parameters to better select
    #     # the data
    #
    #     # Unauthenticated client only works with public data sets. Note
    #     # 'None' in place of application token, and no username or password:
    #     client = Socrata(self.data_dir, None)
    #     # Results, returned as JSON from API / converted to Python list of
    #     # dictionaries by sodapy.
    #     results = client.get(self.file_name, location=location, limit=limit)
    #     # Convert to pandas DataFrame
    #     results_df = pd.DataFrame.from_records(results)
    #
    #     return results_df


class SyntheticDataReader(DataReader):
    file_extension = '.csv'
    synthetic_dir = ('C:\\Users\\fvall\\Documents\\Research\\TrafficSimulation'
                     '\\synthetic_data\\')
    synthetic_sim_name = 'synthetic_data'

    def __init__(self):
        self.sim_number = 0
        self.column_names = ['time', 'veh_id', 'veh_type', 'link', 'lane', 'x',
                             'vx', 'y', 'leader_id', 'delta_x']
        DataReader.__init__(self, self.synthetic_dir, self.synthetic_sim_name)
        self.data_source = 'synthetic'

    def load_data(self):
        self.file_name = self.network_name
        full_address = os.path.join(self.data_dir,
                                    self.file_name + self.file_extension)
        with open(full_address, 'r') as file:
            data = pd.read_csv(file)
        self.select_relevant_columns(data)
        return data
