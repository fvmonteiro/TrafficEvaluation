import os
from typing import Union
from typing import List
import warnings

import pandas as pd
# from sodapy import Socrata
import xml.etree.ElementTree as ET

import file_handling
from vehicle import VehicleType

vissim_networks_folder = file_handling.get_networks_folder()


def match_sim_number_to_random_seed(data):
    """Matches each simulation number to the used random seed. This is only
    possible if we know the initial random seed, the random seed increment,
    and the number of runs per vehicle input."""
    # TODO: where should this function and these constants be saved?
    # These variables are needed because we only save the simulation number,
    # which doesn't mean much unless all percentages had the
    # exact same number of simulations.
    _first_simulation_number = 1  # TODO: depends on the scenario
    _runs_per_input = 10
    _initial_random_seed = 7
    _random_seed_increment = 1
    if not data.empty:
        data['random_seed'] = _initial_random_seed + (
                (data['simulation_number'] - _first_simulation_number)
                % _runs_per_input) * _random_seed_increment


class DataReader:
    relevant_columns = {'time', 'veh_id', 'veh_type', 'link', 'lane',
                        'x', 'vx', 'y', 'leader_id', 'delta_x', 'leader_type',
                        'front_x', 'front_y', 'rear_x', 'rear_y', 'length',
                        'delta_v', 'lane_change'}

    def __init__(self, data_dir=None, network_name=None):
        self.data_dir = data_dir
        self.network_name = network_name

    def load_data(self, file_identifier) -> pd.DataFrame:
        raise NotImplementedError

    def get_data_folder(self,
                        vehicle_type: List[VehicleType],
                        controlled_percentage: List[int],
                        vehicles_per_lane: int) -> str:
        """
        Creates a string with the full path of the simulation results data
        folder. If all parameters are None, returns the test data folder

        :param vehicle_type: Enum to indicate the vehicle (controller) type
        :param controlled_percentage: Percentage of autonomous vehicles
         in the simulation. Current possible values: 0:25:100
        :param vehicles_per_lane: Vehicle input per lane on VISSIM. Possible
         values depend on the controlled_vehicles_percentage: 500:500:2500
        :return: string with the folder where the data is
        """
        if (vehicle_type is None and controlled_percentage is None
                and vehicles_per_lane is None):
            return os.path.join(self.data_dir, 'test')

        percent_folder = file_handling.create_percent_folder_name(
            controlled_percentage, vehicle_type)
        vehicle_input_folder = file_handling.create_vehs_per_lane_folder_name(
            vehicles_per_lane)
        return os.path.join(self.data_dir, percent_folder, vehicle_input_folder)

    @staticmethod
    def _select_relevant_columns(data):
        columns_to_drop = []
        for col in data.columns:
            if col not in DataReader.relevant_columns:
                columns_to_drop.append(col)
        data.drop(columns=columns_to_drop, inplace=True)


class VissimDataReader(DataReader):
    """Base class to read data generated by VISSIM"""

    def __init__(self, network_name: str,
                 file_format: str, separator: str,
                 data_identifier: str, header_identifier: str,
                 header_map: dict):

        network_relative_path = (
            file_handling.get_relative_address_from_network_name(network_name))
        network_data_dir = os.path.join(vissim_networks_folder,
                                        network_relative_path)
        DataReader.__init__(self, network_data_dir,
                            network_name)
        # self.vehicle_type = vehicle_type.name.lower()
        self.file_format = file_format
        self.separator = separator
        self.data_identifier = data_identifier
        self.header_identifier = header_identifier
        self.header_map = header_map

    @staticmethod
    def load_max_deceleration_data():
        """ Loads data describing maximum deceleration distribution per vehicle
         type and velocity

        :return: pandas dataframe with double index
        """
        max_deceleration_data = pd.read_csv(os.path.join(
            vissim_networks_folder, 'max_decel_data.csv'))
        kph_to_mps = 1 / 3.6
        max_deceleration_data['vel'] = max_deceleration_data['vel'] * kph_to_mps
        max_deceleration_data.set_index(['veh_type', 'vel'], inplace=True)
        return max_deceleration_data

    def create_full_file_address(self, file_identifier: Union[int, str],
                                 vehicle_type: List[VehicleType],
                                 controlled_vehicles_percentage: List[int],
                                 vehicles_per_lane: int) -> str:
        """

        :param file_identifier: This can be either a integer indicating
         the simulation number or the file name directly
        :param vehicle_type: Enum to indicate the vehicle (controller) type
        :param controlled_vehicles_percentage: Percentage of autonomous vehicles
         in the simulation. Current possible values: 0:25:100
        :param vehicles_per_lane: Vehicle input per lane on VISSIM. Possible
         values depend on the controlled_vehicles_percentage: 500:500:2500
        :return: string with the full file address ready to be opened
        """
        if isinstance(file_identifier, str):
            file_name = file_identifier
        else:
            # Create a three-character string with trailing zeros and then
            # sim_nums (e.g.: _004, _015, _326)
            num_str = '_' + str(file_identifier).rjust(3, '0')
            network_file = file_handling.get_file_name_from_network_name(
                self.network_name)
            file_name = (network_file + self.data_identifier
                         + num_str + self.file_format)
        data_folder = self.get_data_folder(vehicle_type,
                                           controlled_vehicles_percentage,
                                           vehicles_per_lane)
        return os.path.join(data_folder, file_name)

    def load_data(self, file_identifier: Union[int, str],
                  vehicle_type: List[VehicleType] = None,
                  controlled_vehicles_percentage: List[int] = None,
                  vehicles_per_lane: int = None,
                  n_rows: int = None):
        """ Loads data from one file of a chosen network with given
        vehicle input and controlled vehicle percentage

        :param file_identifier: This can be either a integer indicating
         the simulation number or the file name directly
        :param vehicle_type: Enum to indicate the vehicle (controller) type
        :param controlled_vehicles_percentage: Percentage of autonomous vehicles
         in the simulation. Current possible values: 0:25:100
        :param vehicles_per_lane: Vehicle input per lane on VISSIM. Possible
         values depend on the controlled_vehicles_percentage: 500:500:2500
        :param n_rows: Number of rows going to be read from the file.
         Used for debugging purposes.
        :return: pandas dataframe with the data
        """

        full_address = self.create_full_file_address(
            file_identifier, vehicle_type, controlled_vehicles_percentage,
            vehicles_per_lane)
        try:
            with open(full_address, 'r') as file:
                # Skip header lines
                for line in file:
                    # In all VISSIM files, the data starts after a line such as
                    # '$VEHICLE:'. The variable names are listed after the ':'.
                    if line.startswith(self.header_identifier):
                        header_no_split = line
                        if ':' in header_no_split:
                            header_no_split = line.partition(':')[-1]
                        file_header = header_no_split.rstrip('\n').split(
                            self.separator)
                        break

                column_names = []
                for variable_name in file_header:
                    extra_info = ''
                    if '(' in variable_name:
                        opening_idx = variable_name.find('(')
                        closing_idx = variable_name.find(')')
                        extra_info = (
                            variable_name[opening_idx:closing_idx + 1])
                        variable_name = variable_name[:opening_idx]
                    try:
                        column_names.append(self.header_map[
                                                variable_name.lstrip(' ')]
                                            + extra_info)
                    except KeyError:
                        column_names.append(variable_name.lower())
                data = pd.read_csv(file, sep=self.separator,
                                   names=column_names, index_col=False,
                                   nrows=n_rows)
        except OSError:
            raise ValueError('No VISSIM file with veh type {}, '
                             'percentage {}, veh input {}, file number {}'
                             .format([vt.name.lower() for vt in vehicle_type],
                                     controlled_vehicles_percentage,
                                     vehicles_per_lane, file_identifier))

        data.dropna(axis='columns', how='all', inplace=True)

        # Accept None vehicle_type and vehicles_per_lane during testing phase
        if vehicle_type is not None:
            for i in range(len(vehicle_type)):
                data[vehicle_type[i].name.lower() + '_percentage'] = (
                    controlled_vehicles_percentage[i])
        if vehicles_per_lane is not None:
            data['vehicles_per_lane'] = int(vehicles_per_lane)
        return data

    def load_test_data(self):
        """
        Loads data inside the 'test' folder
        """
        return self.load_data(1)

    def load_data_with_controlled_percentage(
            self, vehicle_type: List[List[VehicleType]],
            vehicle_percentage: List[List[int]],
            vehicle_input: Union[int, List[int]]) -> pd.DataFrame:
        """Loads data from all simulations with the given autonomous
        percentages.

        :param vehicle_type: Enum to indicate the vehicle (controller) type
        :param vehicle_percentage: Percentage of controlled vehicles
         in the simulation. If this is a list, all the data is appended to a 
         single data frame.
        :param vehicle_input:
        :return: pandas dataframe with the data
        """
        # if isinstance(vehicle_percentage, list):
        percentage_copy = vehicle_percentage[:]
        # else:
        # percentage_copy = [vehicle_percentage]
        # if not isinstance(vehicle_type, list):
        #     vehicle_type = [vehicle_type]

        if not isinstance(vehicle_input, list):
            vehicle_input = [vehicle_input]
        desired_folders = set([str(vi) + '_vehs_per_lane'
                               for vi in vehicle_input])

        data_per_folder = []
        for i in range(len(vehicle_type)):
            vt = vehicle_type[i]
            percentage = percentage_copy[i]
            percent_folder = file_handling.create_percent_folder_name(
                percentage, vt)
            percentage_path = os.path.join(self.data_dir, percent_folder)

            # Check all the *_vehs_per_lane folders in the percentage folder
            for folder in os.listdir(percentage_path):
                if (os.path.isdir(os.path.join(percentage_path, folder))
                        and folder in desired_folders):
                    veh_input = int(folder.split('_')[0])
                    min_file_number, max_file_number = (
                        self.find_min_max_file_number(vt, percentage,
                                                      veh_input))
                    # Since files contain cumulative data from all runs
                    # in a set, we only need to read the latest file.
                    new_data = self.load_data(max_file_number, vt,
                                              percentage, veh_input)
                    # Files containing outputs from older simulations
                    # (earlier than Sept. 21 2021) might contain data
                    # from more simulations than just those indicated by
                    # the veh input folder name. Therefore we must drop
                    # some results.
                    if min_file_number != max_file_number:
                        drop_idx = new_data[
                            new_data['simulation_number'] <
                            min_file_number].index
                        new_data.drop(drop_idx, inplace=True)
                    data_per_folder.append(new_data)
            # We only need to load data without any controlled vehicles once
            # if [0] in percentage_copy:
            #     percentage_copy.remove([0])
        data = pd.concat(data_per_folder, ignore_index=True)
        match_sim_number_to_random_seed(data)
        return data

    def load_data_from_several_files(self,
                                     vehicle_type: List[VehicleType],
                                     controlled_vehicles_percentage: List[int],
                                     vehicles_per_lane: int,
                                     first_file_number: int,
                                     last_file_number: int) -> pd.DataFrame:
        """Reads and aggregates data from several simulations with a given
        percentage of controlled vehicles.

        :param vehicle_type: Enum to indicate the vehicle (controller) type
        :param controlled_vehicles_percentage: Percentage of autonomous vehicles
         in the simulation. Current possible values: 0:25:100
        :param vehicles_per_lane: Vehicle input per lane on VISSIM. Possible
         values depend on the controlled_vehicles_percentage: 500:500:2500
        :param first_file_number: simulation run number of the first file
        :param last_file_number: simulation run number of the last file
        :return: single aggregated pandas dataframe """

        sim_output = []
        for i in range(first_file_number, last_file_number + 1):
            try:
                new_data = self.load_data(
                    i, vehicle_type, controlled_vehicles_percentage,
                    vehicles_per_lane)
                if 'simulation_number' not in new_data.columns:
                    new_data['simulation_number'] = i
                sim_output.append(new_data)
            except ValueError:
                warnings.warn('Tried to load simulations from {} to {}, '
                              'but stopped at {}'.
                              format(first_file_number, last_file_number, i))
                break

        return pd.concat(sim_output, ignore_index=True)

    def find_min_max_file_number(self, vehicle_type: List[VehicleType],
                                 percentage: List[int],
                                 vehicles_per_lane: int) -> (int, int):
        """"Looks for the file with the highest simulation number. This is
        usually the file containing results from all simulations.

        :param vehicle_type: Enum to indicate the vehicle (controller) type
        :param percentage: Percentage of autonomous vehicles
         in the simulation.
        :param vehicles_per_lane: Vehicle input per lane used in simulation
        :return: highest simulation number. """
        max_simulation_number = -1
        min_simulation_number = 10000
        results_folder = self.get_data_folder(vehicle_type, percentage,
                                              vehicles_per_lane)
        network_file = file_handling.get_file_name_from_network_name(
            self.network_name)
        for file in os.listdir(results_folder):
            file_str = os.fsdecode(file)
            if (file_str.startswith(network_file + self.data_identifier)
                    and file_str.endswith(self.file_format)):
                file_no_extension = file_str.split('.')[0]
                try:
                    sim_number = int(file_no_extension.split('_')[-1])
                except ValueError:
                    print('File {} is not being read because its name does not '
                          'end with a number.'.format(file_no_extension))
                    continue
                if sim_number > max_simulation_number:
                    max_simulation_number = sim_number
                if sim_number < min_simulation_number:
                    min_simulation_number = sim_number

        return min_simulation_number, max_simulation_number


class VehicleRecordReader(VissimDataReader):
    """Reads vehicle records generated by VISSIM"""

    _file_format = '.fzp'
    _separator = ';'
    _data_identifier = ''
    _header_identifier = '$VEHICLE'
    _header_map = {
        'SIMRUN': 'simulation_number', 'SIMSEC': 'time', 'NO': 'veh_id',
        'VEHTYPE': 'veh_type', 'LANE\\LINK\\NO': 'link',
        'LANE\\INDEX': 'lane', 'POS': 'x', 'SPEED': 'vx',
        'ACCELERATION': 'ax', 'POSLAT': 'y', 'LEADTARGNO': 'leader_id',
        'FOLLOWDIST': 'vissim_delta_x',
        'COORDFRONTX': 'front_x', 'COORDFRONTY': 'front_y',
        'COORDREARX': 'rear_x', 'COORDREARY': 'rear_y',
        'SPEEDDIFF': 'vissim_delta_v', 'LENGTH': 'length',
        'LNCHG': 'lane_change', 'GIVECONTROLTOVISSIM': 'vissim_control',
        'LEADTARGTYPE': 'target_type'
    }

    # Note: we don't necessarily want all the variables listed in each of the
    # map above

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    # def load_data(self, file_identifier,
    #               vehicle_type: VehicleType = None,
    #               controlled_vehicles_percentage: int = 0,
    #               vehicles_per_lane: int = None,
    #               n_rows: int = None) -> pd.DataFrame:
    #     """ Loads data from simulations of a chosen network and selects
    #     the relevant variables to keep.
    #
    #     :param file_identifier: Number identifying the simulation run
    #     :param vehicle_type: TODO
    #     :param controlled_vehicles_percentage: Percentage of autonomous vehicles
    #      in the simulation.
    #     :param vehicles_per_lane: Vehicle input per lane used in simulation
    #     :param n_rows: Number of rows going to be read from the file.
    #      Used for debugging purposes.
    #     :return: pandas dataframes
    #     """
    #     data = VissimDataReader.load_data(self, file_identifier, vehicle_type,
    #                                       controlled_vehicles_percentage,
    #                                       vehicles_per_lane, n_rows)
    #     # self.select_relevant_columns(data)
    #     return data

    # # TODO: this method should not be available to this class. What's the
    # #  proper OO approach?
    # def load_data_with_controlled_vehicles_percentage(self, percentage):
    #     print('Not yet sure if it is a good idea to have such a function for '
    #           'vehicle record data.')
    #     return

    def generate_data(self,
                      vehicle_type: List[VehicleType],
                      percentage: List[int],
                      vehicle_inputs: List[int] = None, n_rows: int = None):
        """
        Yields all the vehicle record files for the chosen simulation scenario.

        :param vehicle_type:
        :param percentage: Percentage of autonomous vehicles in the simulation.
        :param vehicle_inputs: Vehicle input per lane used in simulation.
         Default value is None, which means we'll read all available
         simulations.
        :param n_rows: Number of rows going to be read from the file.
         Used for debugging purposes.
        :return:
        """

        # if not isinstance(vehicle_type, list):
        #     vehicle_type = [vehicle_type]

        # for i, vt in iter(vehicle_type):
        percent_folder = file_handling.create_percent_folder_name(
            percentage, vehicle_type)
        percentage_path = os.path.join(self.data_dir, percent_folder)

        # Check all the *_vehs_per_lane folders in the percentage folder
        for folder in os.listdir(percentage_path):
            if (os.path.isdir(os.path.join(percentage_path, folder))
                    and folder.endswith('vehs_per_lane')):
                veh_input = int(folder.split('_')[0])
                if (vehicle_inputs is not None
                        and veh_input not in vehicle_inputs):
                    continue
                min_file_number, max_file_number = (
                    self.find_min_max_file_number(vehicle_type, percentage,
                                                  veh_input))
                for file_number in range(min_file_number,
                                         max_file_number + 1):
                    print('Loading file number {} / {}'.format(
                        file_number - min_file_number + 1,
                        max_file_number - min_file_number + 1))
                    yield (self.load_data(file_number, vehicle_type, percentage,
                                          veh_input, n_rows),
                           file_number)


class ReducedSpeedAreaReader(VissimDataReader):
    """Reads data from reduced speed areas used in a VISSIM simulation"""

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Reduced Speed Areas'
    _header_identifier = '$REDUCEDSPEEDAREA'
    _header_map = {
        'NO': 'number', 'NAME': 'name', 'LANE': 'lane', 'POS': 'position',
        'LENGTH': 'length', 'TIMEFROM': 'time_from', 'TIMETO': 'time_to',
        'DESSPEEDDISTR': 'speed_limit', 'DECEL': 'max_approach_deceleration'
    }

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    def load_data_with_controlled_percentage(self, vehicle_type,
                                             vehicle_percentage,
                                             vehicle_input=None):
        print('Not yet coded.')
        return


class DataCollectionReader(VissimDataReader):
    """Reads data generated from data collection measurements in VISSIM"""

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Data Collection Results'
    _header_identifier = '$DATACOLLECTIONMEASUREMENTEVALUATION'
    _header_map = {
        'SIMRUN': 'simulation_number', 'TIMEINT': 'time_interval',
        'DATACOLLECTIONMEASUREMENT': 'sensor_number',
        'DIST': 'distance', 'VEHS': 'vehicle_count',
        'QUEUEDELAY': 'queue_delay', 'OCCUPRATE': 'occupancy_rate',
        'ACCELERATION': 'acceleration', 'LENGTH': 'length',
        'PERS': 'people count', 'SPEEDAVGARITH': 'speed_avg',
        'SPEEDAVGHARM': 'speed_harmonic_avg'
    }

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    def load_data(self, file_identifier, vehicle_type: List[VehicleType] = None,
                  controlled_vehicles_percentage: List[int] = None,
                  vehicles_per_lane: int = None,
                  n_rows: int = None) -> pd.DataFrame:
        data = super().load_data(file_identifier, vehicle_type,
                                 controlled_vehicles_percentage,
                                 vehicles_per_lane, n_rows)
        # Some column names contain (ALL). We can remove that information
        column_names = [name.split('(')[0] for name in data.columns]
        data.columns = column_names
        # Include flow
        time_interval = data['time_interval'].iloc[0]
        data['flow'] = self._compute_flow(data['vehicle_count'], time_interval)
        return data

    @staticmethod
    def _compute_flow(vehicle_count: pd.Series, measurement_interval: str):
        interval_start, _, interval_end = measurement_interval.partition('-')
        measurement_period = int(interval_end) - int(interval_start)
        seconds_in_hour = 3600
        return seconds_in_hour / measurement_period * vehicle_count


class LinkEvaluationReader(VissimDataReader):
    """Reads data generated from link evaluation measurements in VISSIM"""

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Link Segment Results'
    _header_identifier = '$LINKEVALSEGMENTEVALUATION'
    _header_map = {
        'SIMRUN': 'simulation_number', 'TIMEINT': 'time_interval',
        'LINKEVALSEGMENT': 'link_segment_number', 'DENSITY': 'density',
        'DELAYREL': 'delay_relative', 'SPEED': 'average_speed',
        'VOLUME': 'volume'
    }

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    def load_data(self, file_identifier, vehicle_type: List[VehicleType] = None,
                  controlled_vehicles_percentage: List[int] = 0,
                  vehicles_per_lane: int = None,
                  n_rows: int = None) -> pd.DataFrame:
        data = super().load_data(file_identifier, vehicle_type,
                                 controlled_vehicles_percentage,
                                 vehicles_per_lane, n_rows)
        # Some column names contain (ALL). We can remove that information
        column_names = [name.split('(')[0] for name in data.columns]
        data.columns = column_names
        return data


class VehicleInputReader(VissimDataReader):
    """Reads files containing simulation vehicle input """

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Vehicle Inputs'
    _header_identifier = '$VEHICLEINPUT'
    _header_map = {'NO': 'number', 'NAME': 'name', 'LINK': 'link',
                   'VOLUME': 'vehicle_input', 'VEHCOMP': 'vehicle_composition'}

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    # def load_data_with_controlled_vehicles_percentage(
    #         self, percentage: Union[int, List[int]]) -> pd.DataFrame:
    #     return super().load_data_with_controlled_vehicles_percentage(
    #         percentage)


class LaneChangeReader(VissimDataReader):
    """Reads lane change data"""

    _file_format = '.spw'
    _separator = ';'
    _data_identifier = ''
    _header_identifier = 't; VehNo;'
    _header_map = {
        't': 'start_time', 'VehNo': 'veh_id', 'v [m/s]': 'vx',
        'Link No.': 'link', 'Lane': 'origin_lane', 'New Lane': 'dest_lane',
        'VF': 'lo_id', 'v VF [m/s]': 'lo_vx',
        'dv VF [m/s]': 'lo_delta_vx', 'dx VF [m]': 'lo_gap',
        'VB': 'fo_id', 'v VB': 'fo_vx',
        'dv VB [m/s]': 'fo_delta_vx', 'dx VB': 'fo_gap',
        'new VF': 'ld_id', 'v new VF [m/s]': 'ld_vx',
        'dv new VF [m/s]': 'ld_delta_vx', 'dx new VF [m]': 'ld_gap',
        'new VB': 'fd_id', 'v new VB [m/s]': 'fd_vx',
        'dv new VB [m/s]': 'fd_delta_vx', 'dx new VB [m]': 'fd_gap',
    }

    def __init__(self, network_name):
        VissimDataReader.__init__(self, network_name,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)


class PostProcessedDataReader(DataReader):
    """
    Base class to read safety data extracted from vissim simulations
    """
    file_format = '.csv'
    data_identifier = ''

    def __init__(self, network_name: str, data_identifier: str):
        network_relative_path = (
            file_handling.get_relative_address_from_network_name(network_name))
        network_data_dir = os.path.join(
            file_handling.get_networks_folder(),
            network_relative_path)
        DataReader.__init__(self, network_data_dir, network_name)
        # self.vehicle_type = vehicle_type.name.lower()
        self.data_identifier = data_identifier

    def load_data(self, file_identifier: List[VehicleType],
                  controlled_vehicles_percentage: List[int] = None,
                  vehicles_per_lane: int = None) -> pd.DataFrame:
        """
        Loads data from one file of a chosen network with given
        vehicle input and controlled vehicle percentage

        :param file_identifier: enum that defines the vehicle (controller) type
        :param controlled_vehicles_percentage: indicates the controlled vehicles
         percentage
        :param vehicles_per_lane: Vehicle input per lane on VISSIM. Possible
         values depend on the controlled_vehicles_percentage: 500:500:2500
        :return: pandas dataframe with the data
        """

        vehicle_type = file_identifier
        data_folder = self.get_data_folder(vehicle_type,
                                           controlled_vehicles_percentage,
                                           vehicles_per_lane)
        network_file = file_handling.get_file_name_from_network_name(
            self.network_name)
        file_name = (network_file + self.data_identifier + self.file_format)
        full_address = os.path.join(data_folder, file_name)
        try:
            data = pd.read_csv(full_address)
        except OSError:
            # Old format files end with a three digit number. Let's try to
            # read that before giving up
            file_name = self._load_file_starting_with_name(network_file,
                                                           data_folder)
            full_address = os.path.join(data_folder, file_name)
            data = pd.read_csv(full_address)
        data['vehicles_per_lane'] = vehicles_per_lane
        for i in range(len(vehicle_type)):
            data[vehicle_type[i].name.lower() + '_percentage'] = (
                controlled_vehicles_percentage[i])
        return data

    def load_data_with_controlled_percentage(
            self, vehicle_type: List[List[VehicleType]],
            vehicle_percentage: List[List[int]],
            vehicle_input: Union[int, List[int]] = None) -> pd.DataFrame:
        """Loads data from all simulations with the given autonomous
        percentages.

        :param vehicle_type: Enum that defines the vehicle (controller) type
        :param vehicle_percentage: Percentage of controlled vehicles
         in the simulation. If this is a list, all the data is appended to a
         single data frame.
        :param vehicle_input: TODO
        :return: pandas dataframe with the data
        """
        percentage_copy = vehicle_percentage[:]

        if not isinstance(vehicle_input, list):
            vehicle_input = [vehicle_input]
        desired_folders = set([str(vi) + '_vehs_per_lane'
                               for vi in vehicle_input])

        data_per_folder = []
        # for vt in vehicle_type:
        #     for percentage in percentage_copy:
        for i in range(len(vehicle_type)):
            vt = vehicle_type[i]
            percentage = percentage_copy[i]
            percent_folder = file_handling.create_percent_folder_name(
                percentage, vt)
            percentage_path = os.path.join(self.data_dir, percent_folder)

            # Check all the *_vehs_per_lane folders in the percentage folder
            for folder in os.listdir(percentage_path):
                if (os.path.isdir(os.path.join(percentage_path, folder))
                        and folder in desired_folders):
                    veh_input = int(folder.split('_')[0])
                    data_per_folder.append(self.load_data(
                        vt, percentage, veh_input))
            # We only need to load data without any controlled vehicles once
            # if [0] in percentage_copy:
            #     percentage_copy.remove([0])
        data = pd.concat(data_per_folder, ignore_index=True)
        # match_sim_number_to_random_seed(data)
        return data

    def _load_file_starting_with_name(self, network_file, data_folder):
        base_name = network_file + self.data_identifier
        file_with_longer_name = []
        for file in os.listdir(data_folder):
            file_str = os.fsdecode(file)
            if file_str.startswith(base_name):
                file_with_longer_name.append(file_str)
        if len(file_with_longer_name) > 1:
            raise OSError('Too many possible files starting with {} '
                          'at {} found'.format(self.data_identifier,
                                               data_folder))
        if len(file_with_longer_name) == 0:
            raise OSError('No {} file at {}'.format(self.data_identifier,
                                                    data_folder))
        return file_with_longer_name[0]


class SSMDataReader(PostProcessedDataReader):
    """Reads aggregated SSM data obtained after processing vehicle record
    data"""

    _data_identifier = '_SSM Results'

    def __init__(self, network_name):
        PostProcessedDataReader.__init__(self, network_name,
                                         self._data_identifier)

    def load_data(self, file_identifier,
                  controlled_vehicles_percentage: int = None,
                  vehicles_per_lane: int = None) -> pd.DataFrame:
        """

        :param file_identifier: indicates the controlled vehicles percentage
        :param controlled_vehicles_percentage: indicates the controlled vehicles
         percentage
        :param vehicles_per_lane: Vehicle input per lane used in simulation
        :return: SSM data for the requested simulation
        """
        data = super().load_data(file_identifier,
                                 controlled_vehicles_percentage,
                                 vehicles_per_lane)
        # Ensure compatibility with previous naming convention
        data.rename(columns={'exact_risk': 'risk'}, inplace=True)
        data.rename(columns={
            'exact_risk_no_lane_change': 'risk_no_lane_change'}, inplace=True)
        return data


class RiskyManeuverReader(PostProcessedDataReader):
    _data_identifier = '_Risky Maneuvers'

    def __init__(self, network_name):
        PostProcessedDataReader.__init__(self, network_name,
                                         self._data_identifier)


class ViolationsReader(PostProcessedDataReader):
    _data_identifier = '_Traffic Light Violations'

    def __init__(self, network_name):
        PostProcessedDataReader.__init__(self, network_name,
                                         self._data_identifier)


class DiscomfortReader(PostProcessedDataReader):
    _data_identifier = '_Discomfort'

    def __init__(self, network_name):
        PostProcessedDataReader.__init__(self, network_name,
                                         self._data_identifier)


class MergedDataReader(PostProcessedDataReader):
    _data_identifier = '_Merged Data'

    def __init__(self, network_name: str):
        PostProcessedDataReader.__init__(self, network_name,
                                         self._data_identifier)
        # network_file = file_handling.get_file_name_from_network_name(
        #     network_name)
        # network_relative_address = (file_handling.
        #     get_relative_address_from_network_name(
        #     network_name))
        # network_data_dir = os.path.join(vissim_networks_folder,
        #                                 network_relative_address)
        # DataReader.__init__(self, network_data_dir,
        #                     network_name)
        # self.vehicle_type = vehicle_type.name.lower()
        # # File name is always the same here. Only the folder changes
        # self.file_name = (network_file + self._data_identifier
        #                   + self._file_extension)

    def load_data(self, file_identifier,
                  controlled_vehicles_percentage: int = None,
                  vehicles_per_lane: int = None) -> pd.DataFrame:
        """

        :param file_identifier: enum that defines the vehicle (controller) type
        :param controlled_vehicles_percentage: indicates the controlled vehicles
         percentage
        :param vehicles_per_lane: Vehicle input per lane on VISSIM. Must not
         be set for this class of readers cause they read directly from the
         percentage folder.
        :return: pandas dataframe with the data
        """
        if vehicles_per_lane is not None:
            print('Merged data readers ignore vehicles_per_lane '
                  'parameter, since these files are in the parent'
                  'percentage folder.')
        return super().load_data(file_identifier)

    def load_data_with_controlled_percentage(
            self, vehicle_type: Union[VehicleType, List[VehicleType]],
            vehicle_percentage: Union[int, List[int]],
            vehicle_input: Union[int, List[int]] = None) -> pd.DataFrame:
        """

        :param vehicle_type:
        :param vehicle_percentage:
        :param vehicle_input:
        :return:
        """
        raise NotImplementedError

    def load_multiple_data(self, vehicle_type: List[VehicleType],
                           percentages: List[int]) -> pd.DataFrame:

        # if not isinstance(percentages, list):
        #     percentages = [percentages]

        data = []
        for p in percentages:
            new_data = self.load_data(vehicle_type, p)
            data.append(new_data)
        return pd.concat(data, ignore_index=True)


class NGSIMDataReader(DataReader):
    """Reads raw vehicle trajectory data from NGSIM scenarios on the US-101"""

    file_extension = '.csv'
    ngsim_dir = ('C:\\Users\\fvall\\Documents\\Research\\TrafficSimulation'
                 '\\NGSIM_original\\')
    location_switch = {'us-101': 'US-101-LosAngeles-CA\\us-101-vehicle'
                                 '-trajectory-data'}
    interval_switch = {1: '0750am-0805am', 2: '0805am-0820am',
                       3: '0820am-0835am'}
    ngsim_to_reader_naming = {'Global_Time': 'time', 'Vehicle_ID': 'veh_id',
                              'v_Class': 'veh_type', 'Local_Y': 'x',
                              'v_Vel': 'vx', 'Local_X': 'y',
                              'Preceding': 'leader_id', 'Lane_ID': 'lane',
                              'Space_Hdwy': 'delta_x', 'v_Length': 'length'}

    def __init__(self, location):
        # self.interval = 0
        try:
            data_dir = os.path.join(self.ngsim_dir,
                                    self.location_switch[location])
            file_name = 'trajectories-'
        except KeyError:
            print('{}: KeyError: location {} not defined'.
                  format(self.__class__.__name__, location))
            data_dir = None
            file_name = None
        DataReader.__init__(self, data_dir, file_name)
        self.data_source = 'NGSIM'

    def load_data(self, file_identifier=1):

        if file_identifier not in self.interval_switch:
            print('Requested interval not available')
            return pd.DataFrame()

        # self.interval = interval
        file_name = self.network_name + self.interval_switch[file_identifier]
        full_address = os.path.join(self.data_dir,
                                    file_name + self.file_extension)
        try:
            with open(full_address, 'r') as file:
                data = pd.read_csv(file)
                data.rename(columns=self.ngsim_to_reader_naming, inplace=True)
        except OSError:
            raise ValueError('No NGSIM file with name {}'.format(file_name))

        self._select_relevant_columns(data)
        return data

    # def get_simulation_identifier(self):
    #     """Returns the time of the day of the data which was loaded last"""
    #     return self.interval_switch[self.interval]


class SyntheticDataReader(DataReader):
    file_extension = '.csv'
    synthetic_dir = ('C:\\Users\\fvall\\Documents\\Research\\TrafficSimulation'
                     '\\synthetic_data\\')
    synthetic_sim_name = 'synthetic_data'

    def __init__(self):
        self.sim_number = 0
        self.column_names = ['time', 'veh_id', 'veh_type', 'link', 'lane', 'x',
                             'vx', 'y', 'leader_id', 'delta_x']
        DataReader.__init__(self, self.synthetic_dir, self.synthetic_sim_name)
        self.data_source = 'synthetic'

    def load_data(self, file_identifier=None):
        file_name = self.network_name
        full_address = os.path.join(self.data_dir,
                                    file_name + self.file_extension)
        with open(full_address, 'r') as file:
            data = pd.read_csv(file)
        self._select_relevant_columns(data)
        return data

    def load_test_data(self):
        return self.load_data()


class TrafficLightSourceReader:
    _file_extension = '.csv'
    _data_identifier = '_source_times'

    def __init__(self, network_name: str):
        file = (file_handling.get_relative_address_from_network_name(
            network_name) + self._data_identifier + self._file_extension)
        self._file_address = os.path.join(vissim_networks_folder,
                                          file)

    def load_data(self) -> pd.DataFrame:
        tl_data = pd.read_csv(self._file_address)
        if 'starts_red' not in tl_data.columns:
            tl_data['starts_red'] = True
        tl_data['cycle_time'] = (
                tl_data['red duration']
                + tl_data['green duration']
                + tl_data['amber duration'])
        return tl_data


class SignalControllerFileReader(DataReader):
    _file_extension = '.sig'

    def __init__(self, network_name):
        DataReader.__init__(self, vissim_networks_folder, network_name)

    def load_data(self, file_identifier: int) -> ET.ElementTree:
        """

        :param file_identifier: Indicates the id of the signal controller
        :return:
        """
        relative_address = (
            file_handling.get_relative_address_from_network_name(
                self.network_name))
        full_address = os.path.join(self.data_dir, relative_address
                                    + str(file_identifier)
                                    + self._file_extension)
        try:
            with open(full_address, 'r') as file:
                return ET.parse(file)
        except OSError:
            raise ValueError('File {} not found'.format(full_address))


# DEPRECATED CLASSES #
class PostProcessedDataReader_OLD(DataReader):
    file_extension = '.csv'
    post_processed_dir = ('C:\\Users\\fvall\\Documents\\Research'
                          '\\TrafficSimulation\\post_processed_data')

    # file_source_dict = {'highway_in_and_out_lanes': 'VISSIM',
    #                     'I710-MultiSec-3mi': 'VISSIM',
    #                     # 'US_101': 'VISSIM',
    #                     'us-101': 'NGSIM',
    #                     'synthetic_data': 'synthetic_data'}

    def __init__(self, data_source, file_name: str = None):
        # if file_name not in self.file_source_dict:
        #     raise ValueError('No post-processed file with name {}'.
        #                      format(file_name))
        self.data_source = data_source
        if data_source.lower() == 'vissim':
            file_name = file_handling.get_file_name_from_network_name(
                file_name)
        elif data_source.lower() == 'ngsim':
            file_name = 'trajectories-'
        elif data_source.lower == 'synthetic':
            file_name = 'synthetic_data'

        data_dir = os.path.join(self.post_processed_dir, self.data_source)
        DataReader.__init__(self, data_dir, file_name)

    def load_data(self, file_identifier=1):
        """ Loads post processed vehicle data from VISSIM or NGSIM
        :return: pandas dataframe
        """
        if self.data_source.lower() == 'vissim':
            file_identifier = str(file_identifier).rjust(3, '0')
            self.network_name += '_' + file_identifier
        elif self.data_source.lower() == 'ngsim':
            file_identifier = (
                NGSIMDataReader.interval_switch[file_identifier])
            self.network_name += file_identifier
        elif self.data_source.lower() == 'synthetic_data':
            pass  # self.file_name is already the correct file name
        else:
            raise ValueError('Unknown data source: ', self.data_source)

        network_file = file_handling.get_file_name_from_network_name(
            self.network_name)
        full_address = os.path.join(self.data_dir,
                                    network_file + self.file_extension)
        return pd.read_csv(full_address)


class OnLineDataReader(DataReader):
    """"Class to read NGSIM data online, commands from
    https://dev.socrata.com/foundry/data.transportation.gov/8ect-6jqj
    Data details in:
    https://data.transportation.gov/Automobiles/Next-Generation-Simulation-
    NGSIM-Vehicle-Trajector/8ect-6jqj"""

    def __init__(self):
        url = "data.transportation.gov"
        database_identifier = "8ect-6jqj"
        DataReader.__init__(self, url, database_identifier)
        self.data_source = 'NGSIM_online'

    # def load_data(self, location='us-101', limit='2000'):
    #     """
    #     :param location: peachtree, i-80, us-101, lankershim
    #     :param limit: max number of rows
    #     :return: pandas dataframe
    #     """
    #     # The get function can receive SQL-like parameters to better select
    #     # the data
    #
    #     # Unauthenticated client only works with public data sets. Note
    #     # 'None' in place of application token, and no username or password:
    #     client = Socrata(self.data_dir, None)
    #     # Results, returned as JSON from API / converted to Python list of
    #     # dictionaries by sodapy.
    #     results = client.get(self.file_name, location=location, limit=limit)
    #     # Convert to pandas DataFrame
    #     results_df = pd.DataFrame.from_records(results)
    #
    #     return results_df
