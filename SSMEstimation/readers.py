import os
from typing import Union
from typing import List
import warnings

import pandas as pd
# from sodapy import Socrata

from vehicle import VehicleType
from vissim_interface import VissimInterface


class DataReader:
    relevant_columns = {'time', 'veh_id', 'veh_type', 'link', 'lane',
                        'x', 'vx', 'y', 'leader_id', 'delta_x', 'leader_type',
                        'front_x', 'front_y', 'rear_x', 'rear_y', 'length',
                        'delta_v', 'lane_change'}

    def __init__(self, data_dir=None, network_name=None):
        self.data_dir = data_dir
        self.network_name = network_name

    def load_data(self, file_identifier) -> pd.DataFrame:
        raise NotImplementedError

    @staticmethod
    def _select_relevant_columns(data):
        columns_to_drop = []
        for col in data.columns:
            if col not in DataReader.relevant_columns:
                columns_to_drop.append(col)
        data.drop(columns=columns_to_drop, inplace=True)


class VissimDataReader(DataReader):
    """Base class to read data generated by VISSIM"""

    vissim_networks_folder = VissimInterface.networks_folder
    controlled_vehicle_types = [VehicleType.ACC,
                                VehicleType.AUTONOMOUS,
                                VehicleType.CONNECTED]
    # These variables are needed because we only save the simulation number,
    # which doesn't mean much unless all percentages had the
    # exact same number of simulations.
    _first_simulation_number = 2
    _runs_per_input = 10
    _initial_random_seed = 7
    _random_seed_increment = 1

    def __init__(self, network_name: str, vehicle_type: VehicleType,
                 file_format: str, separator: str,
                 data_identifier: str, header_identifier: str,
                 header_map: dict):

        network_file = VissimInterface.get_file_name_from_network_name(
            network_name)
        network_data_dir = os.path.join(self.vissim_networks_folder,
                                        network_file)
        DataReader.__init__(self, network_data_dir,
                            network_file)
        self.vehicle_type = vehicle_type.name.lower()
        self.file_format = file_format
        self.separator = separator
        self.data_identifier = data_identifier
        self.header_identifier = header_identifier
        self.header_map = header_map

    @staticmethod
    def load_max_deceleration_data():
        """ Loads data describing maximum deceleration distribution per vehicle
         type and velocity

        :return: pandas dataframe with double index
        """
        max_deceleration_data = pd.read_csv(os.path.join(
            VissimDataReader.vissim_networks_folder, 'max_decel_data.csv'))
        kph_to_mps = 1 / 3.6
        max_deceleration_data['vel'] = max_deceleration_data['vel'] * kph_to_mps
        max_deceleration_data.set_index(['veh_type', 'vel'], inplace=True)
        return max_deceleration_data

    @staticmethod
    def load_simulation_vehicle_inputs():
        if VissimDataReader._vehicle_inputs.empty:
            VissimDataReader._vehicle_inputs = pd.read_csv(os.path.join(
                VissimDataReader.vissim_networks_folder,
                'simulated_vehicle_inputs.csv'))

    def load_data(self, file_identifier: Union[int, str],
                  controlled_vehicles_percentage: int = None,
                  vehicles_per_lane: int = None,
                  n_rows: int = None):
        """ Loads data from one file of a chosen network with given
        vehicle input and controlled vehicle percentage

        :param file_identifier: This can be either a integer indicating
         the simulation number or the file name directly
        :param controlled_vehicles_percentage: Percentage of autonomous vehicles
         in the simulation. Current possible values: 0:25:100
        :param vehicles_per_lane: Vehicle input per lane on VISSIM. Possible
         values depend on the controlled_vehicles_percentage: 500:500:2500
        :param n_rows: Number of rows going to be read from the file.
         Used for debugging purposes.
        :return: pandas dataframe with the data
        """

        if isinstance(file_identifier, str):
            file_name = file_identifier
        else:
            # Create a three-character string with trailing zeros and then
            # sim_nums (e.g.: _004, _015, _326)
            num_str = '_' + str(file_identifier).rjust(3, '0')
            file_name = (self.network_name + self.data_identifier
                         + num_str + self.file_format)

        percent_folder = VissimInterface.create_percent_folder_name(
            controlled_vehicles_percentage, self.vehicle_type)
        vehicle_input_folder = VissimInterface.create_vehs_per_lane_folder_name(
            vehicles_per_lane)

        full_address = os.path.join(self.data_dir, percent_folder,
                                    vehicle_input_folder, file_name)
        try:
            with open(full_address, 'r') as file:
                # Skip header lines
                for line in file:
                    # In all VISSIM files, the data starts after a line such as
                    # '$VEHICLE:'. The variable names are listed after the ':'.
                    if line.startswith(self.header_identifier):
                        header_no_split = line
                        if ':' in header_no_split:
                            header_no_split = line.partition(':')[-1]
                        file_header = header_no_split.rstrip('\n').split(
                            self.separator)
                        break

                if self.header_map:
                    column_names = []
                    for variable_name in file_header:
                        extra_info = ''
                        if '(' in variable_name:
                            opening_idx = variable_name.find('(')
                            closing_idx = variable_name.find(')')
                            extra_info = (
                                variable_name[opening_idx:closing_idx + 1])
                            variable_name = variable_name[:opening_idx]
                        column_names.append(self.header_map[variable_name]
                                            + extra_info)
                else:
                    column_names = file_header
                if n_rows is None:
                    data = pd.read_csv(file, sep=self.separator,
                                       names=column_names, index_col=False)
                else:
                    data = pd.read_csv(file, sep=self.separator,
                                       names=column_names, index_col=False,
                                       nrows=n_rows)
        except OSError:
            raise ValueError('No VISSIM file with name {}'.format(file_name))

        data.dropna(axis='columns', how='all', inplace=True)
        data[self.vehicle_type + '_percentage'] = (
            controlled_vehicles_percentage)
        data['vehicles_per_lane'] = int(vehicles_per_lane)
        # self._match_sim_number_to_vehicle_input(sim_output)
        return data

    def load_data_with_controlled_vehicles_percentage(
            self, percentage: Union[int, List[int]]) -> pd.DataFrame:
        """Loads data from all simulations with the given autonomous
        percentages.

        :param percentage: Percentage of controlled vehicles
         in the simulation. If this is a list, all the data is appended to a 
         single data frame.
        :return: pandas dataframe with the data
        """
        if not isinstance(percentage, list):
            percentage = [percentage]

        data = pd.DataFrame()
        for i in range(len(percentage)):
            percent_folder = VissimInterface.create_percent_folder_name(
                percentage[i], self.vehicle_type)
            percentage_path = os.path.join(self.data_dir, percent_folder)

            # Check all the *_vehs_per_lane folders in the percentage folder
            for folder in os.listdir(percentage_path):
                if (os.path.isdir(os.path.join(percentage_path, folder))
                        and folder.endswith('vehs_per_lane')):
                    veh_input = int(folder.split('_')[0])
                    min_file_number, max_file_number = (
                        self.find_min_max_file_number(
                            percentage[i], veh_input))
                    if max_file_number < 0:  # no file found
                        continue
                    # Since files contain cumulative data from all runs in a
                    # set, we only need to read the latest file.
                    new_data = self.load_data(max_file_number,
                                              percentage[i], veh_input)

                    # Files containing outputs from older simulations (earlier
                    # than Sept. 21 2021) might contain data from more
                    # simulations than just those indicated by the veh input
                    # folder name. Therefore we must drop some results.
                    if min_file_number != max_file_number:
                        new_data.drop(
                            new_data[new_data['simulation_number'] <
                                     min_file_number].index, inplace=True)

                    if data.empty:
                        data = new_data
                    else:
                        data = data.append(new_data, ignore_index=True)
        self.match_sim_number_to_random_seed(data)
        return data

    def load_data_from_several_files(self, controlled_vehicles_percentage,
                                     first_file_number,
                                     last_file_number) -> pd.DataFrame:
        """Reads and aggregates data from several simulations with a given
        percentage of controlled vehicles.

        :param controlled_vehicles_percentage: Percentage of controlled vehicles
         in the simulation
        :param first_file_number: simulation run number of the first file
        :param last_file_number: simulation run number of the last file
        :return: single aggregated pandas dataframe """

        sim_output = pd.DataFrame()
        for i in range(first_file_number, last_file_number + 1):
            try:
                new_data = self.load_data(
                    i, controlled_vehicles_percentage)
                if 'simulation_number' not in new_data.columns:
                    new_data['simulation_number'] = i

                if sim_output.empty:
                    sim_output = new_data
                else:
                    sim_output = sim_output.append(new_data, ignore_index=True)
            except ValueError:
                warnings.warn('Tried to load simulations from {} to {}, '
                              'but stopped at {}'.
                              format(first_file_number, last_file_number, i))
                break
        return sim_output

    def find_min_max_file_number(self, percentage: Union[int, str],
                                 vehicles_per_lane: int = None) -> (int, int):
        """"Looks for the file with the highest simulation number. This is
        usually the file containing results from all simulations.

        :param percentage: Percentage of autonomous vehicles
         in the simulation.
        :param vehicles_per_lane: Vehicle input per lane used in simulation
        :return: highest simulation number. """
        max_simulation_number = -1
        min_simulation_number = 10000
        percentage_folder = VissimInterface.create_percent_folder_name(
            percentage, self.vehicle_type)
        if vehicles_per_lane:
            vehicle_input_folder = (VissimInterface.
                                    create_vehs_per_lane_folder_name(
                                        vehicles_per_lane))
            results_full_path = os.path.join(self.data_dir, percentage_folder,
                                             vehicle_input_folder)
        else:
            results_full_path = os.path.join(self.data_dir, percentage_folder)

        for file in os.listdir(results_full_path):
            file_str = os.fsdecode(file)
            if (file_str.startswith(self.network_name + self.data_identifier)
                    and file_str.endswith(self.file_format)):
                file_no_extension = file_str.split('.')[0]
                sim_number = int(file_no_extension.split('_')[-1])
                if sim_number > max_simulation_number:
                    max_simulation_number = sim_number
                if sim_number < min_simulation_number:
                    min_simulation_number = sim_number

        return min_simulation_number, max_simulation_number

    def match_sim_number_to_random_seed(self, data):
        """Matches each simulation number to the used random seed. This is
        possible knowing the initial random seed, the random seed increment,
        and the number of runs per vehicle input."""
        if not data.empty:
            data['random_seed'] = self._initial_random_seed + (
                    (data['simulation_number'] - self._first_simulation_number)
                    % self._runs_per_input) * self._random_seed_increment


class VehicleRecordReader(VissimDataReader):
    """Reads vehicle records generated by VISSIM"""

    _file_format = '.fzp'
    _separator = ';'
    _data_identifier = ''
    _header_identifier = '$VEHICLE'
    _header_map = {
        'SIMRUN': 'simulation_number', 'SIMSEC': 'time', 'NO': 'veh_id',
        'VEHTYPE': 'veh_type', 'LANE\\LINK\\NO': 'link',
        'LANE\\INDEX': 'lane', 'POS': 'x', 'SPEED': 'vx',
        'ACCELERATION': 'ax', 'POSLAT': 'y', 'LEADTARGNO': 'leader_id',
        'FOLLOWDIST': 'vissim_delta_x',
        'COORDFRONTX': 'front_x', 'COORDFRONTY': 'front_y',
        'COORDREARX': 'rear_x', 'COORDREARY': 'rear_y',
        'SPEEDDIFF': 'vissim_delta_v', 'LENGTH': 'length',
        'LNCHG': 'lane_change', 'GIVECONTROLTOVISSIM': 'vissim_control'
    }

    # Note: we don't necessarily want all the variables listed in each of the
    # map above

    def __init__(self, network_name, vehicle_type):
        VissimDataReader.__init__(self, network_name, vehicle_type,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    def load_data(self, file_identifier,
                  controlled_vehicles_percentage: int = 0,
                  vehicles_per_lane: int = None,
                  n_rows: int = None) -> pd.DataFrame:
        """ Loads data from simulations of a chosen network and selects
        the relevant variables to keep.

        :param file_identifier: Number identifying the simulation run
        :param controlled_vehicles_percentage: Percentage of autonomous vehicles
         in the simulation.
        :param vehicles_per_lane: Vehicle input per lane used in simulation
        :param n_rows: Number of rows going to be read from the file.
         Used for debugging purposes.
        :return: pandas dataframes
        """
        data = VissimDataReader.load_data(self, file_identifier,
                                          controlled_vehicles_percentage,
                                          vehicles_per_lane, n_rows)
        # self.select_relevant_columns(data)
        return data

    # TODO: this method should not be available to this class. What's the
    #  proper OO approach?
    def load_data_with_controlled_vehicles_percentage(self, percentage):
        print('Not yet sure if it is a good idea to have such a function for '
              'vehicle record data.')
        return

    def generate_data(self, percentage: int, vehicle_inputs: List[int] = None,
                      n_rows: int = None):
        """
        Yields all the vehicle record files for the chosen simulation scenario.

        :param percentage: Percentage of autonomous vehicles
         in the simulation.
        :param vehicle_inputs: Vehicle input per lane used in simulation
        :param n_rows: Number of rows going to be read from the file.
         Used for debugging purposes.
        :return:
        """

        percent_folder = VissimInterface.create_percent_folder_name(
            percentage, self.vehicle_type)
        percentage_path = os.path.join(self.data_dir, percent_folder)

        # Check all the *_vehs_per_lane folders in the percentage folder
        for folder in os.listdir(percentage_path):
            if (os.path.isdir(os.path.join(percentage_path, folder))
                    and folder.endswith('vehs_per_lane')):
                veh_input = int(folder.split('_')[0])
                if (vehicle_inputs is not None
                        and veh_input not in vehicle_inputs):
                    continue
                min_file_number, max_file_number = (
                    self.find_min_max_file_number(
                        percentage, veh_input))
                for file_number in range(min_file_number, max_file_number + 1):
                    print('Loading file number {} / {}'.format(
                        file_number - min_file_number + 1,
                        max_file_number - min_file_number + 1))
                    yield (self.load_data(file_number, percentage, veh_input,
                                          n_rows),
                           file_number)


class ReducedSpeedAreaReader(VissimDataReader):
    """Reads data from reduced speed areas used in a VISSIM simulation"""

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Reduced Speed Areas'
    _header_identifier = '$REDUCEDSPEEDAREA'
    _header_map = {
        'NO': 'number', 'NAME': 'name', 'LANE': 'lane', 'POS': 'position',
        'LENGTH': 'length', 'TIMEFROM': 'time_from', 'TIMETO': 'time_to',
        'DESSPEEDDISTR': 'speed_limit', 'DECEL': 'max_approach_deceleration'
    }

    def __init__(self, network_name, vehicle_type):
        VissimDataReader.__init__(self, network_name, vehicle_type,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    def load_data_with_controlled_vehicles_percentage(self,
                                                      percentage):
        print('Not yet coded.')
        return


class DataCollectionReader(VissimDataReader):
    """Reads data generated from data collection measurements in VISSIM"""

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Data Collection Results'
    _header_identifier = '$DATACOLLECTIONMEASUREMENTEVALUATION'
    _header_map = {
        'SIMRUN': 'simulation_number', 'TIMEINT': 'time_interval',
        'DATACOLLECTIONMEASUREMENT': 'sensor_number',
        'DIST': 'distance', 'VEHS': 'vehicle_count',
        'QUEUEDELAY': 'queue_delay', 'OCCUPRATE': 'occupancy_rate'
    }

    def __init__(self, network_name, vehicle_type):
        VissimDataReader.__init__(self, network_name, vehicle_type,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)


class LinkEvaluationReader(VissimDataReader):
    """Reads data generated from link evaluation measurements in VISSIM"""

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Link Segment Results'
    _header_identifier = '$LINKEVALSEGMENTEVALUATION'
    _header_map = {
        'SIMRUN': 'simulation_number', 'TIMEINT': 'time_interval',
        'LINKEVALSEGMENT': 'link_segment_number', 'DENSITY': 'density',
        'DELAYREL': 'delay_relative', 'SPEED': 'average_speed',
        'VOLUME': 'volume'
    }

    def __init__(self, network_name, vehicle_type):
        VissimDataReader.__init__(self, network_name, vehicle_type,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)


class VehicleInputReader(VissimDataReader):
    """Reads files containing simulation vehicle input """

    _file_format = '.att'
    _separator = ';'
    _data_identifier = '_Vehicle Inputs'
    _header_identifier = '$VEHICLEINPUT'
    _header_map = {'NO': 'number', 'NAME': 'name', 'LINK': 'link',
                   'VOLUME': 'vehicle_input', 'VEHCOMP': 'vehicle_composition'}

    def __init__(self, network_name, vehicle_type):
        VissimDataReader.__init__(self, network_name, vehicle_type,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  self._header_identifier, self._header_map)

    # def load_data_with_controlled_vehicles_percentage(
    #         self, percentage: Union[int, List[int]]) -> pd.DataFrame:
    #     return super().load_data_with_controlled_vehicles_percentage(
    #         percentage)


class SSMDataReader(VissimDataReader):
    """Reads aggregated SSM data obtained after processing vehicle record
    data"""

    _file_format = '.csv'
    _separator = ','
    _data_identifier = '_SSM Results'

    def __init__(self, network_name, vehicle_type):
        VissimDataReader.__init__(self, network_name, vehicle_type,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  "", {})

    def load_data(self, file_identifier: int,
                  controlled_vehicles_percentage: [int, str] = 0,
                  vehicles_per_lane: int = None,
                  n_rows: int = None) -> pd.DataFrame:
        """

        :param file_identifier: Simulation number in set of simulations
        :param controlled_vehicles_percentage: Percentage of autonomous
         vehicles in the simulation.
        :param vehicles_per_lane: Vehicle input per lane used in simulation
        :param n_rows: Number of rows going to be read from the file.
         Used for debugging purposes.
        :return: SSM data for the requested simulation
        """
        data = super().load_data(file_identifier,
                                 controlled_vehicles_percentage,
                                 vehicles_per_lane, n_rows)
        # Ensure compatibility with previous naming convention
        data.rename(columns={'exact_risk': 'risk'}, inplace=True)
        data.rename(columns={
            'exact_risk_no_lane_change': 'risk_no_lane_change'}, inplace=True)
        return data


class RiskyManeuverReader(VissimDataReader):
    _file_format = '.csv'
    _separator = ','
    _data_identifier = '_Risky Maneuvers'

    def __init__(self, network_name, vehicle_type):
        VissimDataReader.__init__(self, network_name, vehicle_type,
                                  self._file_format, self._separator,
                                  self._data_identifier,
                                  "", {})


class MergedDataReader(DataReader):
    _file_extension = '.csv'
    vissim_networks_folder = VissimInterface.networks_folder
    _data_identifier = '_Merged Data'

    def __init__(self, network_name: str, vehicle_type: VehicleType):
        network_file = VissimInterface.get_file_name_from_network_name(
            network_name)
        network_data_dir = os.path.join(self.vissim_networks_folder,
                                        network_file)
        DataReader.__init__(self, network_data_dir,
                            network_file)
        self.vehicle_type = vehicle_type.name.lower()
        # File name is always the same here. Only the folder changes
        self.file_name = (self.network_name + self._data_identifier
                          + self._file_extension)

    def load_data(self, file_identifier: int) -> pd.DataFrame:
        """

        :param file_identifier: Indicates the controlled vehicles percentage
        :return:
        """

        percent_folder = VissimInterface.create_percent_folder_name(
                         file_identifier, self.vehicle_type)
        full_address = os.path.join(self.data_dir, percent_folder,
                                    self.file_name)
        try:
            with open(full_address, 'r') as file:
                data = pd.read_csv(file)
        except OSError:
            raise ValueError('No merged data file at {}'.format(full_address))
        return data

    def load_multiple_data(self, percentages: Union[int, List[int]]) \
            -> pd.DataFrame:

        if not isinstance(percentages, list):
            percentages = [percentages]

        data = pd.DataFrame()
        for p in percentages:
            new_data = self.load_data(p)
            data = new_data if data.empty else data.append(new_data)
        return data


class NGSIMDataReader(DataReader):
    """Reads raw vehicle trajectory data from NGSIM scenarios on the US-101"""

    file_extension = '.csv'
    ngsim_dir = ('C:\\Users\\fvall\\Documents\\Research\\TrafficSimulation'
                 '\\NGSIM_original\\')
    location_switch = {'us-101': 'US-101-LosAngeles-CA\\us-101-vehicle'
                                 '-trajectory-data'}
    interval_switch = {1: '0750am-0805am', 2: '0805am-0820am',
                       3: '0820am-0835am'}
    ngsim_to_reader_naming = {'Global_Time': 'time', 'Vehicle_ID': 'veh_id',
                              'v_Class': 'veh_type', 'Local_Y': 'x',
                              'v_Vel': 'vx', 'Local_X': 'y',
                              'Preceding': 'leader_id', 'Lane_ID': 'lane',
                              'Space_Hdwy': 'delta_x', 'v_Length': 'length'}

    def __init__(self, location):
        # self.interval = 0
        try:
            data_dir = os.path.join(self.ngsim_dir,
                                    self.location_switch[location])
            file_name = 'trajectories-'
        except KeyError:
            print('{}: KeyError: location {} not defined'.
                  format(self.__class__.__name__, location))
            data_dir = None
            file_name = None
        DataReader.__init__(self, data_dir, file_name)
        self.data_source = 'NGSIM'

    def load_data(self, file_identifier=1):

        if file_identifier not in self.interval_switch:
            print('Requested interval not available')
            return pd.DataFrame()

        # self.interval = interval
        file_name = self.network_name + self.interval_switch[file_identifier]
        full_address = os.path.join(self.data_dir,
                                    file_name + self.file_extension)
        try:
            with open(full_address, 'r') as file:
                data = pd.read_csv(file)
                data.rename(columns=self.ngsim_to_reader_naming, inplace=True)
        except OSError:
            raise ValueError('No NGSIM file with name {}'.format(file_name))

        self._select_relevant_columns(data)
        return data

    # def get_simulation_identifier(self):
    #     """Returns the time of the day of the data which was loaded last"""
    #     return self.interval_switch[self.interval]


class PostProcessedDataReader(DataReader):
    file_extension = '.csv'
    post_processed_dir = ('C:\\Users\\fvall\\Documents\\Research'
                          '\\TrafficSimulation\\post_processed_data')

    # file_source_dict = {'highway_in_and_out_lanes': 'VISSIM',
    #                     'I710-MultiSec-3mi': 'VISSIM',
    #                     # 'US_101': 'VISSIM',
    #                     'us-101': 'NGSIM',
    #                     'synthetic_data': 'synthetic_data'}

    def __init__(self, data_source, file_name: str = None):
        # if file_name not in self.file_source_dict:
        #     raise ValueError('No post-processed file with name {}'.
        #                      format(file_name))
        self.data_source = data_source
        if (data_source.lower() == 'vissim'
                and file_name in VissimInterface.network_names_map):
            file_name = VissimInterface.network_names_map[file_name]
        elif data_source.lower() == 'ngsim':
            file_name = 'trajectories-'
        elif data_source.lower == 'synthetic':
            file_name = 'synthetic_data'

        data_dir = os.path.join(self.post_processed_dir, self.data_source)
        DataReader.__init__(self, data_dir, file_name)

    def load_data(self, file_identifier=1):
        """ Loads post processed vehicle data from VISSIM or NGSIM
        :return: pandas dataframe
        """
        if self.data_source.lower() == 'vissim':
            file_identifier = str(file_identifier).rjust(3, '0')
            self.network_name += '_' + file_identifier
        elif self.data_source.lower() == 'ngsim':
            file_identifier = (
                NGSIMDataReader.interval_switch[file_identifier])
            self.network_name += file_identifier
        elif self.data_source.lower() == 'synthetic_data':
            pass  # self.file_name is already the correct file name
        else:
            raise ValueError('Unknown data source: ', self.data_source)

        full_address = os.path.join(self.data_dir,
                                    self.network_name + self.file_extension)
        return pd.read_csv(full_address)


class OnLineDataReader(DataReader):
    """"Class to read NGSIM data online, commands from
    https://dev.socrata.com/foundry/data.transportation.gov/8ect-6jqj
    Data details in:
    https://data.transportation.gov/Automobiles/Next-Generation-Simulation-
    NGSIM-Vehicle-Trajector/8ect-6jqj"""

    def __init__(self):
        url = "data.transportation.gov"
        database_identifier = "8ect-6jqj"
        DataReader.__init__(self, url, database_identifier)
        self.data_source = 'NGSIM_online'

    # def load_data(self, location='us-101', limit='2000'):
    #     """
    #     :param location: peachtree, i-80, us-101, lankershim
    #     :param limit: max number of rows
    #     :return: pandas dataframe
    #     """
    #     # The get function can receive SQL-like parameters to better select
    #     # the data
    #
    #     # Unauthenticated client only works with public data sets. Note
    #     # 'None' in place of application token, and no username or password:
    #     client = Socrata(self.data_dir, None)
    #     # Results, returned as JSON from API / converted to Python list of
    #     # dictionaries by sodapy.
    #     results = client.get(self.file_name, location=location, limit=limit)
    #     # Convert to pandas DataFrame
    #     results_df = pd.DataFrame.from_records(results)
    #
    #     return results_df


class SyntheticDataReader(DataReader):
    file_extension = '.csv'
    synthetic_dir = ('C:\\Users\\fvall\\Documents\\Research\\TrafficSimulation'
                     '\\synthetic_data\\')
    synthetic_sim_name = 'synthetic_data'

    def __init__(self):
        self.sim_number = 0
        self.column_names = ['time', 'veh_id', 'veh_type', 'link', 'lane', 'x',
                             'vx', 'y', 'leader_id', 'delta_x']
        DataReader.__init__(self, self.synthetic_dir, self.synthetic_sim_name)
        self.data_source = 'synthetic'

    def load_data(self, file_identifier=None):
        file_name = self.network_name
        full_address = os.path.join(self.data_dir,
                                    file_name + self.file_extension)
        with open(full_address, 'r') as file:
            data = pd.read_csv(file)
        self._select_relevant_columns(data)
        return data
